### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

### First-fit
##### init：初始化函数
###### defualt_init:初始化内存管理模块
list_init($free_list)初始化自由链表，向链表互相指，置为空
nr_free=0空闲页面数目置为0

###### page_init: 初始化物理内存的映射，设置一块可用内存。

可用空间0x8000 0000到0x88000000为128MiB空间。考虑到其中的OpensBl占用了0x8000 0000到0x80200000的空间，而kernel占用了0x80200000到end(在链接脚本中定义)的空间，也就是说，实际上我们能用来存东西的空间是从end到0x8800 0000。

具体来说，page_init分配了512M个page结构体，一个page4KB，连续分布因为一个page就代表了一个物理页。

接着，将我们存有`page`的空间置为保留，这部分不能给用户使用，用于页面状态等记录，然后对于剩下的空间，我们进行init_memmap.

###### init_memmap: 初始化内存映射
第一个page作为首页”链入free_list即可，page的property属性被置为它管理的页面数量n，而其它的page的property属性均为0。

每个page的flag属性表示是否空闲，所以每次进入free list的块中的所有页，要把flag置位SETPROPERTY，反之，则需要清位CLEARPROPERTY。

如果空闲链表为空，直接将base添加到链表中，反之遍历链表找到合适位置插入base

#### alloc and free: 分配界面
	free_list用以管理空闲块,分配的时候摘取free list中的一块;回收的时候，我们需要把一个块重新放回到free list里边。对于first fit算法，其实就是每次选择free_list中的第一个大小合适的块分配，在回收的时候，也按照地址顺序回收。
	具体而言，分配时遍历可用页面，寻找第一个可用的页面，如果找到了删除该页面链表节点，如改页面管理数目大于n则分为两部分，一部分减去n生成新页面，最后更新可用页面数量。
	释放时，重置页面状态，使其管理页面数变为n，更新可用页面数量。为了减轻这个问题，我们有必要将回收的地址连续的块合并在一起。

#### 关于优化的思考
##### 关于空间的优化
first fit算法最大的弊端就是在一系列反复的“分配-释放”之后，内存空间会变得零碎(即使有合并)。如何解决这个问题呢？
可以采用“内存紧凑”的方法，就是每隔一段时间，把不连续的内存重新分配一下；但显然这样的弊端也很明显，先不谈按怎样的方式才能排得紧凑，但是内存的I/O就开销巨大(当然可以在进程sleep的时候去挪动)，究竟合不合算也不清楚。

其次就是考虑“动态分配”的方式，就是检查局部内存利用率，然后对于利用率低的部分，将空闲的块进行强制合并。

挑战 :
	实现页面的连续分配需要设计一个链表结构来链接不同区域的内存块。
	在内存回收阶段，清晰地梳理和归还这些“东拼西凑”的空间是复杂的，需多次检查相邻空间。

最后，应该可以利用缓存的思想，比如内存池，可能有助于提高内存管理的效率。

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

在无法提前获取当前硬件的可用物理内存范围的情况下，操作系统可以通过以下方法获取可用的物理内存范围：

1. **BIOS/UEFI**：操作系统可以通过与计算机的基本输入/输出系统（BIOS）或统一的扩展固件接口（UEFI）进行通信，以获取关于硬件配置和内存布局的信息。BIOS/UEFI通常提供了访问内存映射表（Memory Mapping Table）或其他相关数据结构的接口。

2. **物理内存管理单元**（Memory Management Unit，**MMU**）：操作系统可以通过与MMU进行交互，获取有关物理内存的信息。由于MMU负责将虚拟内存地址转换为物理内存地址，并维护页面表（Page Table）或其他数据结构来跟踪内存分页情况，所以操作系统可以通过访问MMU的相关数据结构，从而获取可用的物理内存范围。

3. **物理内存映射文件**（Physical Memory Mapping File）：操作系统可以通过创建一个特殊的文件，将物理内存映射到该文件中。然后，操作系统可以读取该文件的内容以获取有关物理内存范围的信息。这种方法常用于调试和诊断目的，需要特权级的访问权限。

> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
